<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Events Map - Grouped by Opened Month & Year</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    /* --------------------------------------------------------------
       Existing styles from your original code
       -------------------------------------------------------------- */
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }

    #app-container {
      display: flex;
      height: 100%;
      width: 100%;
    }

    /* Left side: Map */
    #map {
      flex: 1;
      height: 100%;
    }

    /* Right side: Event list + details */
    #event-panel {
      flex: 1;
      max-width: 50%;
      display: flex;
      flex-direction: column;
      border-left: 2px solid #ccc;
      overflow-y: hidden;
    }

    /* Event list (collapses or hides when an event is selected) */
    #event-list {
      flex: 1;
      overflow-y: auto;
      padding: 0.5rem;
      transition: all 0.3s ease; /* Smooth transitions */
    }

    .group-header {
      background: #eee;
      padding: 0.5rem;
      font-weight: bold;
      margin-top: 1rem;
      border-radius: 4px;
    }

    .event-item {
      padding: 0.5rem;
      margin: 0.25rem 0;
      border: 1px solid #eee;
      border-radius: 4px;
      cursor: pointer; /* The left border is dynamically set in JS, based on event type */
    }
    .event-item:hover {
      background-color: #f0f0f0;
    }

    .selected {
      background-color: #e0f3ff !important;
      border-color: #007bff !important;
    }

    /* The details area can expand to fill entire right side when event is selected */
    #details-area {
      flex: 0 0 auto;       /* default minimal height */
      padding: 0.5rem;
      border-top: 2px solid #ccc;
      overflow-y: auto;     /* allow scrolling in details */
      transition: all 0.3s ease;
    }

    /* If the details are 'focused', hide event list and expand details */
    .details-focused #event-list {
      display: none; /* hide the list altogether */
    }
    .details-focused #details-area {
      flex: 1;       /* fill the right panel  */
      height: 100vh; /* fill viewport height */
    }

    /* Close button styling */
    #close-detail-btn {
      padding: 0.5rem 1rem;
      margin-bottom: 0.75rem;
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #close-detail-btn:hover {
      background: #0056b3;
    }

    /* --------------------------------------------------------------
       New styles for the mini carousel and the fullscreen modal
       -------------------------------------------------------------- */

    /* Mini carousel styling (appears in Leaflet popup) */
    .photo-carousel {
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      max-width: 300px; /* The width of the small carousel in popup */
      overflow: hidden;
      position: relative;
    }
    .carousel-photo {
      width: 300px;
      height: 200px;
      object-fit: cover; /* zoom/crop to fill area */
      display: none;     /* only the current one is shown */
      cursor: pointer;   /* indicates clickable for full screen */
    }
    .carousel-nav-btn {
      background: rgba(0,0,0,0.5);
      color: #fff;
      border: none;
      padding: 0.5rem;
      cursor: pointer;
      position: absolute;
      top: 40%;
      transform: translateY(-50%);
      z-index: 2;
    }
    .carousel-nav-btn:hover {
      background: rgba(0,0,0,0.7);
    }
    .carousel-prev {
      left: 0;
    }
    .carousel-next {
      right: 0;
    }

    /* Fullscreen modal/backdrop for viewing images in detail */
    .photo-modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;  
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;        /* hidden by default; shown via JS */
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    .photo-modal {
      position: relative;
      max-width: 90%;
      max-height: 90%;
      background: #000;
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: center;
    }
    .photo-modal img {
      max-width: 80vw;
      max-height: 80vh;
    }
    .photo-modal-btn {
      background: rgba(255,255,255,0.3);
      color: #fff;
      border: none;
      padding: 1rem;
      cursor: pointer;
      font-size: 1.5rem;
      z-index: 10;
    }
    .photo-modal-btn:hover {
      background: rgba(255,255,255,0.5);
    }
    .modal-prev {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    .modal-next {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
    }
    .modal-close {
      position: absolute;
      top: 0;
      right: 0;
      font-size: 2rem;
      line-height: 1;
    }
  </style>
</head>
<body>
  <div id="app-container">
    <!-- Map on the left -->
    <div id="map"></div>

    <!-- Event list & details on the right -->
    <div id="event-panel">
      <div id="event-list"></div>
      <div id="details-area">
        <div id="detail-content">
          <p>Select an event to see details here.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Fullscreen Photo Modal (hidden by default) -->
  <div id="photoModalBackdrop" class="photo-modal-backdrop" data-current-index="0">
    <div id="photoModalBody" class="photo-modal">
      <button id="modalPrevBtn" class="photo-modal-btn modal-prev">‹</button>
      <img id="modalImage" src="" alt="Full Photo" />
      <button id="modalNextBtn" class="photo-modal-btn modal-next">›</button>
      <button id="modalCloseBtn" class="photo-modal-btn modal-close">✕</button>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script 
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-KxW4B5YmT5OKWJExclihutQcec4uZb2g8o0QBF277Bs="
    crossorigin="">
  </script>

  <!-- Main JS -->
  <script>
    // Basic references
    const map = L.map("map").setView([50.7729962775501, 0.261495157841447], 18);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 40
    }).addTo(map);

    const eventPanel = document.getElementById("event-panel");
    const eventList = document.getElementById("event-list");
    const detailsArea = document.getElementById("details-area");
    const detailContent = document.getElementById("detail-content");

    // We'll store { marker, listItem, eventItem } objects here
    const allEventMarkers = [];

    // Utility: color for markers/borders
    function getMarkerColor(type) {
      const lower = type.toLowerCase();
      if (lower.includes("defect")) return "red";
      if (lower.includes("enquiry")) return "green";
      if (lower.includes("inspection")) return "blue";
      if (lower.includes("steward")) return "orange";
      return "gray";
    }

    // Utility: format date nicely
    function formatDate(dateStr) {
      const dt = new Date(dateStr);
      return dt.toLocaleString("en-GB", {
        day: "numeric", month: "short", year: "numeric",
        hour: "numeric", minute: "2-digit", hour12: true
      });
    }

    // Let’s fetch our events data
    fetch("./events.json")
      .then((resp) => {
        if (!resp.ok) throw new Error("Network response was not ok: " + resp.statusText);
        return resp.json();
      })
      .then((data) => {
        // Sort by "Opened"
        data.sort((a, b) => new Date(a.Opened) - new Date(b.Opened));

        // Group by month-year
        // Group by month-year, then by Defect number
        const grouped = {};
        data.forEach((item) => {
          const dt = new Date(item.Opened);
          const grp = dt.getFullYear().toString();
          const defect = item["Case Number"] || "No Case Number";

          if (!grouped[grp]) grouped[grp] = {};
          if (!grouped[grp][defect]) grouped[grp][defect] = [];

          grouped[grp][defect].push(item);
        });


        // Sort group keys
        const groupKeys = Object.keys(grouped).sort((a, b) => {
          return parseInt(b) - parseInt(a); // descending by year
        });



        // Render
        groupKeys.forEach((gKey) => {
          const monthHeader = document.createElement("div");
          monthHeader.className = "group-header";
          monthHeader.textContent = gKey;
          eventList.appendChild(monthHeader);

          const defectGroups = grouped[gKey];
          const defectKeys = Object.keys(defectGroups).sort();

          defectKeys.forEach(defectKey => {
            const defectHeader = document.createElement("div");
            defectHeader.className = "group-header";
            defectHeader.style.background = "#f5f5f5";
            defectHeader.style.marginLeft = "1rem";
            defectHeader.textContent = `Case: ${defectKey}`;
            eventList.appendChild(defectHeader);

            defectGroups[defectKey].forEach(evt => {
              createEventListItem(evt);
            });
          });
        });

      })
      .catch(err => {
        console.error("Error loading events.json:", err);
        detailContent.innerHTML = `<p style="color:red;">Error: ${err.message}</p>`;
      });

    // Create a list item (and marker if coords) for a single event
    function createEventListItem(eventItem) {
      const globalIndex = allEventMarkers.length;

      // The list item
      const li = document.createElement("div");
      li.className = "event-item";
      li.style.marginLeft = "16px";
      li.style.borderLeft = "3px solid " + getMarkerColor(eventItem.Type);
      li.innerHTML = `
        <strong>${eventItem.Type}</strong><br/>
        ${eventItem.Opened}<br/>
        ${eventItem.Description.substring(0,80)}${(eventItem.Description.length > 80 ? "..." : "")}
      `;
      eventList.appendChild(li);

      // Marker if lat/long
      let marker = null;
      if (eventItem.Lat && eventItem.Long) {
        const lat = parseFloat(eventItem.Lat);
        const lng = parseFloat(eventItem.Long);
        if (!isNaN(lat) && !isNaN(lng)) {
          marker = L.circleMarker([lat, lng], {
            radius: 8,
            fillColor: getMarkerColor(eventItem.Type),
            color: getMarkerColor(eventItem.Type),
            weight: 2,
            fillOpacity: 0.5
          }).addTo(map);

          // Marker click => select
          marker.on("click", () => selectEvent(globalIndex));
        }
      }

      // List item click => select
      li.addEventListener("click", () => selectEvent(globalIndex));

      allEventMarkers.push({ marker, listItem: li, eventItem });
    }

    // Reset selection & detail
    function resetSelection() {
      // Remove "details-focused" => show the list
      eventPanel.classList.remove("details-focused");
      // Reset all markers & list items
      allEventMarkers.forEach(({marker, listItem, eventItem}) => {
        listItem.style.opacity = "1.0";
        listItem.style.borderLeft = `3px solid ${getMarkerColor(eventItem.Type)}`;
        listItem.classList.remove("selected");
        if (marker) {
          marker.setStyle({
            radius: 8,
            fillColor: getMarkerColor(eventItem.Type),
            color: getMarkerColor(eventItem.Type),
            weight: 2,
            fillOpacity: 0.5
          });
        }
      });
      detailContent.innerHTML = `<p>Select an event to see details here.</p>`;
    }

    // Actually select an event
    function selectEvent(idx) {
      const selObj = allEventMarkers[idx];
      const selEvt = selObj.eventItem;

      // We'll define "related" if same Case Number or same non-empty Reference number
      const selCase = selEvt["Case Number"];
      const selRef = selEvt["Reference number"] && selEvt["Reference number"].trim();

      // Loop over all events => fade, highlight, or mark as selected/related
      allEventMarkers.forEach(({marker, listItem, eventItem}, i) => {
        const sameCase = (selCase && eventItem["Case Number"] && (selCase === eventItem["Case Number"]));
        const sameRef = (selRef && eventItem["Reference number"] && (selRef === eventItem["Reference number"].trim()));
        const isRelated = (sameCase || sameRef);

        if (i === idx) {
          // FULL highlight
          listItem.style.opacity = "1.0";
          listItem.classList.add("selected");
          listItem.style.borderLeft = `3px solid ${getMarkerColor(eventItem.Type)}`;
          if (marker) {
            marker.setStyle({
              radius: 16,
              fillColor: getMarkerColor(eventItem.Type),
              color: getMarkerColor(eventItem.Type),
              weight: 4,
              fillOpacity: 1.0
            });
          }
        } else if (isRelated) {
          // It's related => highlight but not as strongly
          listItem.style.opacity = "1.0";
          listItem.classList.remove("selected");
          listItem.style.borderLeft = `3px solid ${getMarkerColor(eventItem.Type)}`;
          if (marker) {
            marker.setStyle({
              radius: 16,
              fillColor: getMarkerColor(eventItem.Type),
              color: getMarkerColor(eventItem.Type),
              weight: 3,
              fillOpacity: 0.7
            });
          }
        } else {
          // Unrelated => fade
          listItem.classList.remove("selected");
          listItem.style.opacity = "0.5";
          listItem.style.borderLeft = `3px solid ${getMarkerColor(eventItem.Type)}`;
          if (marker) {
            marker.setStyle({
              radius: 8,
              weight: 2,
              opacity: 0.1
            });
          }
        }
      });

      // Zoom in if we have a marker
      if (selObj.marker) {
        map.setView(selObj.marker.getLatLng(), 20);

        // Build a mini carousel for the popup
        const photos = [];
        // Collect "Defect number" photos for the selected event
        const defNums = new Set();
        if (selEvt["Defect number"]) {
          defNums.add(selEvt["Defect number"]);
        }
        // You could also gather any "related" event defect numbers here if desired

        defNums.forEach(num => {
          const beforeUrl = `photos/${num}_before.png`;
          const afterUrl = `photos/${num}_after.png`;
          // Push them in if you definitely want them in the carousel
          // (Optionally: You could do a check to confirm the file is valid)
          photos.push(beforeUrl);
          photos.push(afterUrl);
        });

        // If we do have any photos, create the carousel. Otherwise, we can show "No photos" or skip.
        let carouselHTML = '';
        if (photos.length > 0) {
          carouselHTML += `
            <div class="photo-carousel" id="miniCarousel" data-current-index="0">
              <button class="carousel-nav-btn carousel-prev" onclick="prevPhotoInCarousel()">‹</button>
          `;
          photos.forEach((p, i) => {
            let label = '';
            if (p.toLowerCase().includes('_before')) label = 'Before';
            else if (p.toLowerCase().includes('_after')) label = 'After';

            carouselHTML += `
              <div style="position: relative;">
                <img 
                  src="${p}" 
                  class="carousel-photo" 
                  style="display:${i===0 ? 'block' : 'none'}" 
                  onclick="openModalAtIndex(${i})"
                  onerror="this.style.display='none';"
                />
                <div style="
                  position: absolute;
                  bottom: 5px;
                  left: 5px;
                  background: rgba(0,0,0,0.6);
                  color: white;
                  padding: 2px 6px;
                  border-radius: 3px;
                  font-size: 0.85rem;
                  display: ${i===0 ? 'block' : 'none'};
                " class="photo-label">${label}</div>
              </div>
            `;
          });

          carouselHTML += `
              <button class="carousel-nav-btn carousel-next" onclick="nextPhotoInCarousel()">›</button>
            </div>
          `;
        } else {
          carouselHTML += `<p>No photos available.</p>`;
        }

        selObj.marker.bindPopup(carouselHTML, {
          closeButton: true,
          autoPan: true
        }).openPopup();
      }

      // Show/hide details
      eventPanel.classList.add("details-focused");

      // Build the detail HTML (below the "mini carousel" in your side panel)
      detailContent.innerHTML = `
        <button id="close-detail-btn">Close</button>
        <h3>${selEvt.Type}</h3>
        <p>${selEvt.Description.replace(/\n/g, "<br/>")}</p>
        <!-- If you still want to show photos in the side panel,
             you can do so here. Otherwise, remove this block. -->
        <p>
          <strong>Opened:</strong> ${formatDate(selEvt.Opened)}<br/>
          <strong>Due:</strong> ${selEvt.Due || "N/A"}<br/>
          <strong>Closed:</strong> ${selEvt.Closed || "N/A"}<br/>
          <strong>Case Number:</strong> ${selEvt["Case Number"] || "N/A"}<br/>
          <strong>Reference:</strong> ${selEvt["Reference number"] || "N/A"}<br/>
          <strong>Defect Number:</strong> ${selEvt["Defect number"] || "N/A"}<br/>
          <strong>Priority:</strong> ${selEvt.Priority || "N/A"}<br/>
        </p>
        <h4>Related Events</h4>
        <div id="related-container"></div>
      `;

      // Close button
      const closeBtn = document.getElementById("close-detail-btn");
      closeBtn.addEventListener("click", resetSelection);

      // Gather the actual related events to display them in a sub-list
      const relatedContainer = document.getElementById("related-container");
      const relatedEvents = [];

      allEventMarkers.forEach((obj, i) => {
        if (i === idx) return;
        const cCase = obj.eventItem["Case Number"];
        const cRef = obj.eventItem["Reference number"] && obj.eventItem["Reference number"].trim();

        const matchesCase = selCase && cCase && (selCase === cCase);
        const matchesRef  = selRef && cRef && (selRef === cRef);

        if (matchesCase || matchesRef) {
          // It's a related event
          relatedEvents.push({ index: i, event: obj.eventItem });
        }
      });

      if (relatedEvents.length === 0) {
        relatedContainer.innerHTML = "<p>No related events found.</p>";
      } else {
        relatedEvents.forEach(rel => {
          const itemDiv = document.createElement("div");
          itemDiv.className = "event-item";
          itemDiv.style.borderLeft = `3px solid ${getMarkerColor(rel.event.Type)}`;
          itemDiv.style.margin = "0.25rem 0";

          itemDiv.innerHTML = `
            <strong>${rel.event.Opened}</strong><br/>
            ${rel.event.Type}<br/>
            ${rel.event.Description}
          `;

          itemDiv.addEventListener("click", () => selectEvent(rel.index));
          relatedContainer.appendChild(itemDiv);
        });
      }
    }

    /* --------------------------------------------------------------
       Carousel helper functions for the mini carousel in the popup
       -------------------------------------------------------------- */
    function showPhotoAtIndex(carouselId, index) {
      const carousel = document.getElementById(carouselId);
      if (!carousel) return;
      const photos = carousel.querySelectorAll('.carousel-photo');
      if (!photos.length) return;

      // Wrap index around
      if (index < 0) index = photos.length - 1;
      if (index >= photos.length) index = 0;

      // Hide all, then show the one
      photos.forEach((img, i) => {
        const parent = img.parentElement;
        img.style.display = (i === index ? 'block' : 'none');
        if (parent) {
          const label = parent.querySelector('.photo-label');
          if (label) label.style.display = (i === index ? 'block' : 'none');
        }
      });
      carousel.setAttribute('data-current-index', index);
    }

    function nextPhotoInCarousel() {
      const carousel = document.getElementById('miniCarousel');
      if (!carousel) return;
      const currentIndex = parseInt(carousel.getAttribute('data-current-index') || '0', 10);
      showPhotoAtIndex('miniCarousel', currentIndex + 1);
    }

    function prevPhotoInCarousel() {
      const carousel = document.getElementById('miniCarousel');
      if (!carousel) return;
      const currentIndex = parseInt(carousel.getAttribute('data-current-index') || '0', 10);
      showPhotoAtIndex('miniCarousel', currentIndex - 1);
    }

    // Called when user clicks the mini-carousel image
    function openModalAtIndex(index) {
      const backdrop = document.getElementById("photoModalBackdrop");
      backdrop.style.display = "flex";
      backdrop.setAttribute('data-current-index', index);
      showModalPhoto(index);
    }

    /* --------------------------------------------------------------
       Fullscreen modal navigation
       -------------------------------------------------------------- */
    function showModalPhoto(index) {
      const carousel = document.getElementById('miniCarousel');
      if (!carousel) return;
      const photos = carousel.querySelectorAll('.carousel-photo');
      if (!photos.length) return;

      // wrap index
      if (index < 0) index = photos.length - 1;
      if (index >= photos.length) index = 0;

      // set the modal's current index
      const backdrop = document.getElementById("photoModalBackdrop");
      backdrop.setAttribute('data-current-index', index);

      // update the src
      const modalImage = document.getElementById("modalImage");
      modalImage.src = photos[index].src;
    }

    function modalNextPhoto() {
      const backdrop = document.getElementById("photoModalBackdrop");
      let currentIndex = parseInt(backdrop.getAttribute('data-current-index') || '0', 10);
      showModalPhoto(currentIndex + 1);
    }

    function modalPrevPhoto() {
      const backdrop = document.getElementById("photoModalBackdrop");
      let currentIndex = parseInt(backdrop.getAttribute('data-current-index') || '0', 10);
      showModalPhoto(currentIndex - 1);
    }

    function closeModal() {
      const backdrop = document.getElementById("photoModalBackdrop");
      backdrop.style.display = "none";
    }

    // Hook up modal's arrow buttons and close button
    document.getElementById("modalPrevBtn").addEventListener("click", modalPrevPhoto);
    document.getElementById("modalNextBtn").addEventListener("click", modalNextPhoto);
    document.getElementById("modalCloseBtn").addEventListener("click", closeModal);

  </script>
</body>
</html>